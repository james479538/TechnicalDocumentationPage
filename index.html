<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>CodePen - A Pen by james479538</title>
  <link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<nav id="navbar">
  <header>KOTLIN Documentation</header>
  <ul>
    <li><a class="nav-link" href="#Introduction">Introduction</a></li>
    <li>
      <a class="nav-link" href="#What_you_should_already_know"
        >What you should already know</a
      >
    </li>
    <li>
      <a class="nav-link" href="#JavaScript_and_Java">What makes Kotlin better?</a>
    </li>
    <li><a class="nav-link" href="#Hello_world">Kotlin as a more concise Java language</a></li>
    <li><a class="nav-link" href="#Variables">Functional programming in Kotlin</a></li>
    <li>
      <a class="nav-link" href="#Declaring_variables">Using ranges in Kotlin</a>
    </li>
    <li><a class="nav-link" href="#Variable_scope">Safety features in Kotlin</a></li>
    <li><a class="nav-link" href="#Global_variables">Kotlin coroutines</a></li>
    <li><a class="nav-link" href="#Constants">Kotlin for Android</a></li>
    <li><a class="nav-link" href="#Data_types">Kotlin vs. Java</a></li>
    <li><a class="nav-link" href="#Reference">Reference</a></li>
  </ul>
</nav>
<main id="main-doc">
  <section class="main-section" id="Introduction">
    <header>Introduction</header>
    <article>
      <p>
        Kotlin (/ˈkɒtlɪn/) is a cross-platform, statically typed, general-purpose programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library, but type inference allows its syntax to be more concise. Kotlin mainly targets the JVM, but also compiles to JavaScript (e.g., for frontend web applications using React) or native code (via LLVM); e.g., for native iOS apps sharing business logic with Android apps. Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark.
      </p>

      <p>
        Kotlin saves time for developers as the less verbose language provides briefer and less redundant code. Kotlin can be compiled into JavaScript or an LLVM encoder.
      </p>
      <ul>
        <li>
          In many ways, Kotlin is considered a replacement for Java. While it is not compatible with syntax, it is interoperable with Java code and libraries. Kotlin also has its own libraries that were created with its community's early development through an API for Android apps.
        </li>
        <li>
          In Java, a lot of redundancy results in verbose and thus longer code. Kotlin is more modern and has been simplified, making it easier for beginners to learn. Kotlin focuses on stripped down, functional code and avoids repetitive "boilerplate" code. The language features null safety, eliminating null pointer exception errors. Semicolons at the end of every line are not needed, although Kotlin does not have an issue if a developer uses them out of habit. Additional features reduce the complexity and length of code needed to achieve an end goal.
        </li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="What_you_should_already_know">
    <header>What you should already know</header>
    <article>
      <p>This guide assumes you have the following basic background:</p>

      <ul>
        <li>
          Kotlin is a programming language that Android developers can use to build apps that are great while spending less time figuring out the hard parts and debugging test versions. You get great apps, and developers have an easier time writing them.
        </li>
      </ul>
    </article>
  </section>
  <section class="main-section" id="JavaScript_and_Java">
    <header>What makes Kotlin better?</header>
    <article>
      <p>
        Kotlin uses aggressive type inference. That means it can tell what type of data a function is using based on the rest of the code and how it's being used. This means developers don't have to spend time declaring the type of expressions and values in their code unless they are doing something really outside the box. That saves a lot of time because declaring a data type can be tedious and the code has to be perfect.
      </p>

      <p>
        Kotlin lets developers define static objects and functions without needing to use a redundant class. A developer can define the objects and their functions all in one place, so it's a lot easier to read and understand, which makes it easier to debug. And they don't have to include code that shouldn't be needed because it duplicates what they just typed. Java forces this because that's how its syntax works. Kotlin is more relaxed and like writing code in C, and in this case, it's easier and makes more sense.
      </p>
      <p>
        Kotlin's syntax isn't absurdly complex. Java's syntax is. That's why it takes years to be an expert Java developer — you need to include things like semi-colons and braces and brackets in exact places so the compiler (the tool that turns code into an app) knows what to do. Kotlin's syntax uses the best ideas from programming languages that existed before it and writing code is simpler. This also means reading and understanding the code is easier and debugging it takes less time.
      </p>
    </article>
  </section>
  <section class="main-section" id="Hello_world">
    <header>Kotlin as a more concise Java language</header>
    <article>
      At first glance, Kotlin looks like a more concise and streamlined version of Java. Consider the screenshot above, where I have converted a Java code sample (at left) to Kotlin automatically. Notice that the mindless repetition inherent in instantiating Java variables has gone away. The Java idiom
      <code
        >StringBuilder sb = new StringBuilder();
      </code>
      Becomes in Kotlin
      <code
        >val sb = StringBuilder()
      </code>

     You can see that functions are defined with the fun keyword, and that semicolons are now optional when newlines are present. The val keyword declares a read-only property or local variable. Similarly, the var keyword declares a mutable property or local variable.

Nevertheless, Kotlin is strongly typed. The val and var keywords can be used only when the type can be inferred. Otherwise you need to declare the type. Type inference seems to be improving with each release of Kotlin.

Have a look at the function declaration near the top of both panes. The return type in Java precedes the prototype, but in Kotlin it succeeds the prototype, demarcated with a colon as in Pascal.
    </article>
  </section>
  <section class="main-section" id="Variables">
    <header>Functional programming in Kotlin</header>
    <p>
      Allowing top-level functions is just the beginning of the functional programming story for Kotlin. The language also supports higher-order functions, anonymous functions, lambdas, inline functions, closures, tail recursion, and generics. In other words, Kotlin has all of the features and advantages of a functional language. For example, consider the following functional Kotlin idioms.
    </p>
    <p>
      Filtering a list in Kotlin
      <code>val positives = list.filter { x -> x > 0 }</code>
    </p>
    <p>
      For an even shorter expression, use it when there is only a single parameter in the lambda function:
      <code>val positives = list.filter  it > 0               </code>
    </p>
  </section>
  <section class="main-section" id="Declaring_variables">
    <header>Using ranges in Kotlin</header>
    <article>
     Using ranges in Kotlin
      <p>
        <code>for (i in 1..100) { ... }  // closed range: includes 100
for (i in 1 until 100) { ... } // half-open range: does not include 100
for (x in 2..10 step 2) { ... }
for (x in 10 downTo 1) { ... }
if (x in 1..10) { ... }</code>
      </p>
      <p>
        The above examples show the for keyword as well as the use of ranges.
      </p>
      <p>
       Even though Kotlin is a full-fledged functional programming language, it preserves most of the object-oriented nature of Java as an alternative programming style, which is very handy when converting existing Java code. Kotlin has classes with constructors, along with nested, inner, and anonymous inner classes, and it has interfaces like Java 8. Kotlin does not have a new keyword. To create a class instance, call the constructor just like a regular function. We saw that in the screenshot above.

Kotlin has single inheritance from a named superclass, and all Kotlin classes have a default superclass Any, which is not the same as the Java base class java.lang.Object. Any contains only three predefined member functions: equals(), hashCode(), and toString().

Kotlin classes have to be marked with the open keyword in order to allow other classes to inherit from them; Java classes are kind of the opposite, as they are inheritable unless marked with the final keyword. To override a superclass method, the method itself must be marked open, and the subclass method must be marked override. This is all of a piece with Kotlin’s philosophy of making things explicit rather than relying on defaults. In this particular case, I can see where Kotlin’s way of explicitly marking base class members as open for inheritance and derived class members as overrides avoids several kinds of common Java errors.
      </p>
    </article>
  </section>
  <section class="main-section" id="Variable_scope">
    <header>Safety features in Kotlin</header>
    <article>
      <p>
       Speaking of avoiding common errors, Kotlin was designed to eliminate the danger of null pointer references and streamline the handling of null values. It does this by making a null illegal for standard types, adding nullable types, and implementing shortcut notations to handle tests for null.
      </p>

      <p>
        JavaScript before ECMAScript 2015 does not have block statement scope;
        rather, a variable declared within a block is local to the function (or
        global scope) that the block resides within. For example the following
        code will log 5, because the scope of x is the function (or global
        context) within which x is declared, not the block, which in this case
        is an if statement.
      </p>
      <code>if (true) { var x = 5; } console.log(x); // 5</code>
      <p>
        For example, a regular variable of type String cannot hold null:
        <code>var a: String = "abc" 
a = null // compilation error</code>
      </p>

     <p>If you need to allow nulls, for example to hold SQL query results, you can declare a nullable type by appending a question mark to the type, e.g. String?.
       <code>var b: String? ="abc"
b = null // ok</code>
      </p
      >
      <p>The protections go a little further. You can use a non-nullable type with impunity, but you have to test a nullable type for null values before using it.</p>
      <p>To avoid the verbose grammar normally needed for null testing, Kotlin introduces a safe call, written ?.. For example, b?.length returns b.length if b is not null, and null otherwise. The type of this expression is Int?.</p>
      <p>In other words, b?.length is a shortcut for if (b != null) b.length else null. This syntax chains nicely, eliminating quite a lot of prolix logic, especially when an object was populated from a series of database queries, any of which might have failed. For instance, bob?.department?.head?.name would return the name of Bob’s department head if Bob, the department, and the department head are all non-null.</p>
    </article>
  </section>
  <section class="main-section" id="Kotlin coroutines">
    <header>Kotlin coroutines</header>
    <article>
      <p>
        Coroutines in Kotlin are essentially lightweight threads. You start them with the launch coroutine builder in the context of some CoroutineScope. One of the most useful coroutine scopes is runBlocking{}, which applies to the scope of its code block.
        <code>import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine in the scope of runBlocking
        delay(1000L) // non-blocking delay for 1 second
        println("World!")
    }
    println("Hello,")
}</code>
      </p>

      <p>
        This code produces the following output, with a one-second delay between lines:

Hello,
World!
      </p>
    </article>
  </section>
  <section class="main-section" id="Constants">
    <header>Kotlin for Android</header>
    <article>
      <p>
      The question of whether to choose Kotlin or Java for new development has been coming up a lot in the Android community since the Google I/O announcement, although people were already asking the question in February 2016 when Kotlin 1.0 shipped. The short answer is that Kotlin code is safer and more concise than Java code, and that Kotlin and Java files can coexist in Android apps, so that Kotlin is not only useful for new apps, but also for expanding existing Java apps.
      </p>

      
      <p>
       The only cogent argument I have seen for choosing Java over Kotlin would be for the case of complete Android development newbies. For them, there might be a barrier to surmount given that, historically, most Android documentation and examples are in Java. On the other hand, converting Java to Kotlin in Android Studio is a simple matter of pasting the Java code into a Kotlin file.
      </p>

      <p>
      For almost anyone else doing Android development, the advantages of Kotlin are compelling. The typical time quoted for a Java developer to learn Kotlin is a few hours—a small price to pay to eliminate null reference errors, enable extension functions, support functional programming, and add coroutines. The typical rough estimate indicates approximately a 40 percent cut in the number of lines of code from Java to Kotlin.
      </p>

      <p>
        You cannot declare a constant with the same name as a function or
        variable in the same scope. For example:
      </p>

      <p>Kotlin compiles to the same byte code as Java, interoperates with Java classes in natural ways, and shares its tooling with Java. Because there is no overhead for calling back and forth between Kotlin and Java, adding Kotlin incrementally to an Android app currently in Java makes perfect sense. The few cases where the interoperability between Kotlin and Java code lacks grace, such as Java set-only properties, are rarely encountered and easily fixed.</p>
    </article>
  </section>
  <section class="main-section" id="Data_types">
    <header>Kotlin vs. Java</header>
    <article>
      <p>The question of whether to choose Kotlin or Java for new development has been coming up a lot in the Android community since the Google I/O announcement, although people were already asking the question in February 2016 when Kotlin 1.0 shipped. The short answer is that Kotlin code is safer and more concise than Java code, and that Kotlin and Java files can coexist in Android apps, so that Kotlin is not only useful for new apps, but also for expanding existing Java apps.</p>
      <p>The only cogent argument I have seen for choosing Java over Kotlin would be for the case of complete Android development newbies. For them, there might be a barrier to surmount given that, historically, most Android documentation and examples are in Java. On the other hand, converting Java to Kotlin in Android Studio is a simple matter of pasting the Java code into a Kotlin file.</p>
      <p>For almost anyone else doing Android development, the advantages of Kotlin are compelling. The typical time quoted for a Java developer to learn Kotlin is a few hours—a small price to pay to eliminate null reference errors, enable extension functions, support functional programming, and add coroutines. The typical rough estimate indicates approximately a 40 percent cut in the number of lines of code from Java to Kotlin.</p>
    </article>
  </section>
  <section class="main-section" id="Reference">
    <header>Reference</header>
    <article>
      <ul>
        <li>
          All the documentation in this page is taken from
          <a
            href="https://www.infoworld.com/article/3224868/what-is-kotlin-the-java-alternative-explained.html"
            target="_blank"
            >KOTLIN</a
          >
        </li>
      </ul>
    </article>
  </section>
</main>
<!-- partial -->
  <script src='https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js'></script><script  src="./script.js"></script>

</body>
</html>
